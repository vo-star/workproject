package com.example.mtg_deck;

import android.content.ContentValues;
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;
import android.widget.Toast;

public class ThemeDatabaseHelper extends SQLiteOpenHelper {

    private static final String DB_NAME = "theme"; // the name of our database
    private static final int DB_VERSION = 2; // the version of the database

    ThemeDatabaseHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }

    private static void insertEnters1(SQLiteDatabase db, String theme) {
        ContentValues themeEnters = new ContentValues();
        themeEnters.put("THEME", theme);
        db.insert("THEMETEXT", null, themeEnters);
    }

    private static void insertEnters2(SQLiteDatabase db, String tab, String theme, String text) {
        ContentValues textEnters = new ContentValues();
        textEnters.put("TAB", tab);
        textEnters.put("THEME", theme);
        textEnters.put("TEXT", text);
        db.insert("TEXT_THEME", null, textEnters);
    }


    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL("CREATE TABLE THEMETEXT (_id INTEGER PRIMARY KEY AUTOINCREMENT, THEME TEXT); ");
        Log.i("MyLog", "After create table1");
        //added headers
        insertEnters1(db, "Типы");
        insertEnters1(db, "Побитовые операторы");
        insertEnters1(db, "Операторы сравнения");
        insertEnters1(db, "Логические операторы");
       insertEnters1(db, "Оператор if");
        insertEnters1(db, "Цикл while");
        insertEnters1(db, "Цикл do-while");
        insertEnters1(db, "Цикл for");
        insertEnters1(db, "Методы");

        Log.i("MyLog", "After insert1");
        db.execSQL("CREATE TABLE TEXT_THEME (_id INTEGER PRIMARY KEY AUTOINCREMENT, TAB TEXT, THEME TEXT, TEXT TEXT); ");
        Log.i("MyLog", "After create table2");


        //added note

        insertEnters2(db, "", "Типы", "Примитивные типы Java не являются объектами. К ним относятся:");
        insertEnters2(db, " ", "Типы", " boolean - булев тип, может иметь значения true или false");
        insertEnters2(db, " ", "Типы", "byte - 8-разрядное целое число");
        insertEnters2(db, " ", "Типы", " short - 16-разрядное целое число");
        insertEnters2(db, " ", "Типы", " int - 32-разрядное целое число");
        insertEnters2(db, " ", "Типы", " long - 64-разрядное целое число");
        insertEnters2(db, " ", "Типы", " char - 16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)");
        insertEnters2(db, " ", "Типы", "float - 32-разрядное число в формате IEEE 754 с плавающей точкой");
        insertEnters2(db, " ", "Типы", " double - 64-разрядное число в формате IEEE 754 с плавающей точкой");
        insertEnters2(db, " ", "Типы", " Примитивный в данном случае не оскорбление, а просто даёт понять, что речь идёт о простом типе, который не умеет прыгать, спать или мяукать. Да что он вообще умеет? Ой, всё."
                + " Java определяет четыре целочисленных типа: byte, short, int, long. Они могут быть положительными и отрицательными (Java не поддерживает только положительные значения без знака, как некоторые языки программирования)."
                + " Тип byte "
                + " Наименьший по размеру целочисленный тип - byte. Это 8-битовый тип с диапазоном допустимых значений от -128 до 127. Переменные типа byte часто используются при работе с потоком данных из сети или файла, а также при работе с необработанными двоичными данными или в массивах для экономии памяти. "

                + " Объявить переменную типа byte можно следующим образом: ");

        insertEnters2(db, " ", "Типы", "");
        insertEnters2(db, " ", "Типы", " byte c, a, t; // объявили сразу три переменные ");
        insertEnters2(db, " ", "Типы", " ");
        insertEnters2(db, " ", "Типы", " В арифметических выражениях с переменными типа byte вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Смотри пример с short." +
                " Строку с числом перевести в данный тип можно через метод parseByte(String): " +
                "\n" +
                " byte x = Byte.parseByte('100'); " +
                "\n" +
                "Класс Byte является оболочкой для данного типа. Без необходимости не используйте в Android класс Byte. " +
                " Слово «байт» (byte) возникло в компании IBM примерно в 1956 году. Оно произошло от слова bite («кусок»), но его было решено писать через букву y, чтобы не путать со словом «bit» («бит»). В течение некоторого времени слово «байт» обозначало просто число битов в конкретном потоке данных. Однако в середине 1960-х, в связи с разработкой семейства компьютеров System/360 в компании IBM, это слово стало обозначать группу из восьми бит." +
                " Любопытно, что bite имеет также значение 'укус' (сущ.) или 'укусить' (глагол). Таким образом это наш родной 'Кусь!'\");"
                + " В арифметических выражениях с переменными типа byte вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Смотри пример с short."
                + " Строку с числом перевести в данный тип можно через метод parseByte(String): "
                + " byte x = Byte.parseByte('100'); "
                + " Класс Byte является оболочкой для данного типа. Без необходимости не используйте в Android класс Byte. "
                + " Слово «байт» (byte) возникло в компании IBM примерно в 1956 году. Оно произошло от слова bite («кусок»), но его было решено писать через букву y, чтобы не путать со словом «bit» («бит»). В течение некоторого времени слово «байт» обозначало просто число битов в конкретном потоке данных. Однако в середине 1960-х, в связи с разработкой семейства компьютеров System/360 в компании IBM, это слово стало обозначать группу из восьми бит. "
                + " Любопытно, что bite имеет также значение 'укус' (сущ.) или 'укусить' (глагол). Таким образом это наш родной 'Кусь!'");


        insertEnters2(db, "", "Побитовые операторы", "Существует несколько побитовых операторов, применимых к целочисленными типам long, int, short, char, byte.");
        insertEnters2(db, "", "Побитовые операторы", "~\tПобитовый унарный оператор NOT");
        insertEnters2(db, "", "Побитовые операторы", "&\tПобитовый AND");
        insertEnters2(db, "", "Побитовые операторы", "&=\tПобитовый AND с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", "|\tПобитовый OR");
        insertEnters2(db, "", "Побитовые операторы", "|=\tПобитовый OR с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", "^\tПобитовый исключающее OR");
        insertEnters2(db, "", "Побитовые операторы", "^=\tПобитовый исключающее OR с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", ">>\tСдвиг вправо");
        insertEnters2(db, "", "Побитовые операторы", ">>=\tСдвиг вправо с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", ">>>\tСдвиг вправо с заполнением нулями");
        insertEnters2(db, "", "Побитовые операторы", "<<\tСдвиг влево");
        insertEnters2(db, "", "Побитовые операторы", "<<=\tСдвиг влево с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", ">>>=\tСдвиг вправо с заполнением нулями с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", "Все целочисленные типы представляются двоичными числами различной длины. Например, значение типа byte, равное 42, в двоичном представлении имеет вид 00101010, в котором каждая позиция представляет степень числа два."
                + "\n"
                + "\nВсе целочисленные типа, за исключением char - типы со знаком, т.е. могут быть положительными или отрицательными. В Java применяется двоичное дополнение, при котором отрицательные числа представляются в результате инвертирования всех битов значения (изменения 1 на 0 и наоборот) и последующего добавления 1 к результату. Например, -42 представляется в результате инвертирования всех битов в двоичном представлении числа 42, что даёт значение 11010101, и добавления 1, что приводит к значению 110110110, или -42. Чтобы декодировать отрицательное число, необходимо вначале инвертировать все биты, а затем добавить 1 к результату. Например, инвертирование значения -42, или 11010110, приводит к значению 00101001, или 41, после добавления 1 к которому мы получим 42."
                + "\n"
                + "\nДвоичное дополнение используется в большинстве компьютерных языков. Опустим теорию, нужно только помнить, что старший бит определяет знак целого числа.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовые логические операторы");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовые логические операторы - это &, |, ^, ~. Побитовые операторы применяются к каждому отдельному биту каждого операнда.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Результаты выполнения побитовых логических операторов");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "A      B       A|B     A&B     A^B     ~A"
                + "\n"
                + " 0       0         0       0         0            1"
                + "\n"
                + " 1       0         1       0         1            0"
                + "\n"
                + " 0       1         1       0         1            1"
                + "\n"
                + " 1       1         1       1         0            0"

        );
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовое OR (|)");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Результирующий бит, полученный в результате выполнения оператора OR, |, равен 1, если соответствующий бит в любом из операндов равен 1.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", " 00101010  42\n" +
                "| 00001111  15\n" +
                "  --------------\n" +
                "  00101111  47 ");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовое AND (&)");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Значение бита, полученное в результате выполнения побитового оператора AND, &, равно 1, если соответствующие биты в операндах также равны 1. Во всех остальных случаях значение результирующего бита равно 0.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "  00101010  42\n" +
                "& 00001111  15\n" +
                "--------------\n" +
                "  00001010  10");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовое XOR (^)");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Результирующий бит, полученный в результате выполнения оператора XOR, ^, равен 1, если соответствующий бит только в одном из операндов равен 1. Во всех других случаях результирующий бит равен 0.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", " 00101010  42\n" +
                "^ 00001111  15\n" +
                "--------------\n" +
                "  00100101  37  ");
        insertEnters2(db, "", "Побитовые операторы", "Данный оператор обладает полезной особенностью, часто используемый в программировании. Например, можно обменять значения переменных без использования дополнительной переменной");
        insertEnters2(db, "", "Побитовые операторы", "\n" +
                "int x = 5, y = 7;\n" +
                "\n" +
                "x = x ^ y; // стало 2\n" +
                "System.out.println(x);\n" +
                "y = x ^ y; // стало 5\n" +
                "System.out.println(y);\n" +
                "x = x ^ y; //стало 7\n" +
                "System.out.println(x);");
        insertEnters2(db, "", "Побитовые операторы", "Но увлекаться такой записью не стоит, это работает медленнее и код менее читаем.\n" +
                "\n" +
                "Гораздо шире используется XOR для шифрования. В простейшем виде это выглядит так. Есть текст, к которому применяется ключ с оператором XOR. Зашифрованное сообщение передаётся человеку, который знает ключ. Всё, что ему нужно сделать - это применить к зашифрованному тексту тот же ключ, используемый для шифровки и текст снова станет читаемым.\n" +
                "\n" +
                "Ниже приводится приблизительный пример работы шифровки/дешифровки текста. С русским текстом пример не будет работать, так как используются разные кодировки и требуется писать дополнительный код. Итак, у нас есть некий текст, который мы зашифровали с помощью ключа (meow) и передали полученный набор байтов другому человеку. Если кто-то перехватит ваше сообщение, то увидит просто набор символов. А ваш сообщник сможет прочитать сообщение, так как вы заранее условились, каким будем ключ для расшифровки.");
        insertEnters2(db, "", "Побитовые операторы", "public void onClick(View view) {\n" +
                "\n" +
                "\tString message = \"OK, i love you\"; // секретное сообщение\n" +
                "\tString catkey = \"meow\"; // ключ\n" +
                "\n" +
                "\t// зашифруем послание\n" +
                "\tbyte[] important = encode(message, catkey);\n" +
                "\t// посмотрим на результат\n" +
                "\tmInfoTextView.setText(new String(important));\n" +
                "\n" +
                "\t// теперь расшифруем текст\n" +
                "\tmResultEditText.setText(decode(mInfoTextView.getText().toString().getBytes(),\n" +
                "\t\t\tcatkey));\n" +
                "\t\n" +
                "}\n" +
                "\n" +
                "// метод для шифровки текста с помощью XOR\n" +
                "public static byte[] encode(String secret, String key) {\n" +
                "\tbyte[] btxt = null;\n" +
                "\tbyte[] bkey = null;\n" +
                "\n" +
                "\tbtxt = secret.getBytes();\n" +
                "\tbkey = key.getBytes();\n" +
                "\n" +
                "\tbyte[] result = new byte[secret.length()];\n" +
                "\n" +
                "\tfor (int i = 0; i < btxt.length; i++) {\n" +
                "\t\tresult[i] = (byte) (btxt[i] ^ bkey[i % bkey.length]);\n" +
                "\t}\n" +
                "\treturn result;\n" +
                "}\n" +
                "\n" +
                "// метод для расшифровки текста\n" +
                "public static String decode(byte[] secret, String key) {\n" +
                "\tbyte[] result = new byte[secret.length];\n" +
                "\tbyte[] bkey = key.getBytes();\n" +
                "\n" +
                "\tfor (int i = 0; i < secret.length; i++) {\n" +
                "\t\tresult[i] = (byte) (secret[i] ^ bkey[i % bkey.length]);\n" +
                "\t}\n" +
                "\treturn new String(result);\n" +
                "}");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовое NOT (~)");
        insertEnters2(db, "", "Побитовые операторы", "Унарный оператор NOT (Не), ~, называемый также побитовым дополнением, инвертирует все биты операнда. Например, число 42 в битовом представлении имеет вид:");
        insertEnters2(db, "", "Побитовые операторы", "00101010");
        insertEnters2(db, "", "Побитовые операторы", "В результате применения оператора NOT преобразуется в значение:");
        insertEnters2(db, "", "Побитовые операторы", "11010101");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Сдвиг влево");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Оператор сдвига влево, <<, смещает все биты влево на указанное количество позиций:");
        insertEnters2(db, "", "Побитовые операторы", "значение << количество");
        insertEnters2(db, "", "Побитовые операторы", "Параметр количество указывает, на сколько нужно сдвинуть влево биты в параметре значение. При каждом сдвиге влево самый старший бит смещается за пределы допустимого значения и теряется, а справа дописывается нуль. Это означает, что при применении оператора сдвига влево к операнду типа int биты теряются, как только они сдвигаются за пределы 31 позиции. Если операнд имеет тип long, биты теряются после сдвига за пределы 63 позиции.\n" +
                "\n" +
                "Автоматическое повышение типа, используемое в Java, может привести к странным результатам при выполнении сдвига в значениях типа byte, short. При вычислении выражений тип значений byte и short повышается до типа int. Это означает, что результатом выполнения сдвига влево значения типа byte или short будет значение int, и сдвинутые влево позиции не будут отброшены до тех пор, пока они не будут сдвинуты за пределы 31 позиции. Более того, при повышении до типа int отрицательное значение типа byte или short получит дополнительный знаковый разряд. Следовательно, старшие биты будут заполнены единицами. Поэтому выполнение оператора сдвига влево предполагает необходимость отбрасывания старших байтов результата типа int. Иными словами, при выполнении сдвига влево в значении типа byte сначала будет повышение до типа int и лишь затем сдвиг. Это означает, что для получения требуемого сдвинутого значения типа byte необходимо отбросить три старших байта результата. Простейший способ достижения этого - обратное приведение результата к типу byte.");
        insertEnters2(db, "", "Побитовые операторы", "\n" +
                "byte x = 64;\n" +
                "byte y;\n" +
                "int i;\n" +
                "\n" +
                "i = x << 2; // сдвиг влево\n" +
                "y = (byte) (x << 2); // сдвиг влево с приведением\n" +
                "\n" +
                "\n" +
                "mInfoTextView.append(\"i равно: \" + i + \"\\n\");\n" +
                "mInfoTextView.append(\"y равно: \" + y);");
        insertEnters2(db, "", "Побитовые операторы", "Результат будет следующим:");
        insertEnters2(db, "", "Побитовые операторы", "i равно: 256\n" +
                "y равно: 0");
        insertEnters2(db, "", "Побитовые операторы", "Поскольку для выполнения вычислений тип переменной повышается до int, сдвиг влево на две позиции значение 64 (0100 0000) приводит к значению 256 (1 0000 0000). Однако, переменная y содержит значение не 256, а 0, поскольку после сдвига крайний единичный бит оказывается сдвинутым за пределы допустимого диапазона.\n" +
                "\n" +
                "Приёмом сдвига влево часто пользуются в программах, где происходит много сложных вычислений. По сути, это замена операции умножения на 2, которая в силу особенностей процессора гораздо эффективнее. При этом следует соблюдать осторожность, так как при сдвиге единичного бита в старшую позицию (бит 31 или 63) значение становится отрицательным.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Сдвиг вправо");
        insertEnters2(db, "", "Побитовые операторы", "Оператор сдвига вправо, >>, смещает все биты значения вправо на указанное количество позиций:");
        insertEnters2(db, "", "Побитовые операторы", "значение >> количество");
        insertEnters2(db, "", "Побитовые операторы", "Вы указываете количество позиций, на которое нужно сдвинуть вправо биты в значении. Следующий код выполняет сдвиг право на две позиции в значении 32, в результате чего значение переменной станет равным 8.");
        insertEnters2(db, "", "Побитовые операторы", "int a = 32;\n" +
                "a = a >> 2 // стало равным 8");
        insertEnters2(db, "", "Побитовые операторы", "Крайние биты при сдвиге просто теряются. Например, значение 35 при сдвиге вправо на две позиции также приводит к значению 8, так как теряются два младщих бита.");
        insertEnters2(db, "", "Побитовые операторы", "  00100011  35\n" +
                ">>2\n" +
                "----------\n" +
                "  00001000  8");
        insertEnters2(db, "", "Побитовые операторы", "При каждом сдвиге вправо выполняется деление на два с отбрасыванием любого остатка. Данная операция намного эффективнее, чем обычное деление на два, поэтому часто используется в сложных вычислениях. При этом нужно быть уверенным, что никакие биты не будут сдвинуты за пределы правой границы.\n" +
                "\n" +
                "При выполнении сдвига вправо старшие (расположенные в крайних левых позициях) биты, освобожденные в результате сдвига, заполняются предыдущим содержимым старшего бита. Этот эффект называется дополнительных знаковым разрядом и служит для сохранения знака отрицательных чисел при их сдвиге.\n" +
                "\n" +
                "Обратите внимание, что результат сдвига вправо значения -1 всегда равен -1, поскольку дополнительные знаковые разряды добавляют новые единицы к старшим битам.\n" +
                "\n" +
                "Иногда при выполнении сдвига вправо появление дополнительных знаковых разрядов нежелательно. В этом случае используется маскировка за счёт объединения значения со значением 0x0f оператором AND, что приводит к отбрасыванию любых битов дополнительных знаковых разрядов.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Сдвиг вправо без учёта знака");
        insertEnters2(db, "", "Побитовые операторы", "Как было показано выше, при каждом выполнении оператор >> автоматически заполняет старший бит его предыдущим содержимым. В результате знак значения сохраняется. Однако иногда это нежелательно. Например, при работе со значениями пикселей и графическими изображениями. Как правило, в этих случаях требуется сдвиг нуля в позицию старшего бита независимо от его первоначального значения. Такое действие называют сдвигом вправо без учета знака, когда всегда вставляется нуль в позицию старшего бита.\n" +
                "\n" +
                "Допустим, мы хотим сдвинуть вправо на 24 бит значение -1 (в двоичном представлении 11111111 11111111 11111111 11111111):");
        insertEnters2(db, "", "Побитовые операторы", "    11111111 11111111 11111111 11111111\n" +
                ">>> 24\n" +
                "---------------------------------------\n" +
                "    00000000 00000000 00000000 11111111 255 в двоичном виде типа int");
        insertEnters2(db, "", "Побитовые операторы", "Оператор >>> не столь полезен, поскольку имеет смысл только для 32- и 64-разрядных значений.");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Побитовые составные операторы с присваиванием");
        insertEnters2(db, "", "Побитовые операторы", "");
        insertEnters2(db, "", "Побитовые операторы", "Двоичные побитовые операторы имеют составную форму, которая объединяет побитовый оператор с оператором присваивания.");
        insertEnters2(db, "", "Побитовые операторы", "\n" +
                "a = a >> 4;\n" +
                "a >>= 4;\n" +
                "\n" +
                "a = a | b;\n" +
                "a |= b;");


        insertEnters2(db, "", "Операторы сравнения", "Операторы сравнения");
        insertEnters2(db, "", "Операторы сравнения", "");
        insertEnters2(db, "", "Операторы сравнения", "Операторы сравнения выдают логический результат (boolean). Если условие проверки истинно, оператор выдает true, а если ложно - false. К операторам сравнения относятся < (меньше чем), > (больше чем), <= (меньше чем или равно), >= (больше чем или равно), == (равно), != (не равно). Операторы \"Равно\" и \"не равно\" можно использовать для всех примитивных типов данных, однако остальные сравнения нельзя использовать к типу boolean.");
        insertEnters2(db, "", "Операторы сравнения", "Оператор\tПример использования\tВозвращает значение \"истинно\", если...\n" +
                ">      a > b       а больше b\n" +
                ">=     a >= b      а больше или равно b\n" +
                "<      a < b       а меньше b\n" +
                "<=     a <= b      а меньше или равно b\n" +
                "==     a == b     а равно b\n" +
                "!=     a != b      а не равно b\n" +
                "&&     a && b     а и b истинны, b оценивается условно (если а ложно, b не вычисляется)\n" +
                "||     a || b      а или b истинно, b оценивается условно (если а истинно, b не вычисляется)\n" +
                "!      !a          а ложно\n" +
                "&      a & b       а и b истинны, b оценивается в любом случае\n" +
                "|      a | b       а или b истинно, b оценивается в любом случае\n" +
                "^      a ^ b       а и b различны");
        insertEnters2(db, "", "Операторы сравнения", "Наиболее часто операции сравнения используют в выражениях, которые управляют оператором if и операторами цикла.\n" +
                "\n" +
                "Обратите внимание, что равенство обозначается двумя знаками равно (==), одиночный знак равно (=) - это оператор присваивания. Типичная ошибка начинающих программистов.\n" +
                "\n" +
                "Корректный вариант примера:");
        insertEnters2(db, "", "Операторы сравнения", "\n" +
                "int x = 5;\n" +
                "int y = 7;\n" +
                "boolean z = a < b; // результат сохраняется в переменной типа boolean");
        insertEnters2(db, "", "Операторы сравнения", "Примеры для оператора if для Java (В C++ используется другой синтаксис!):");
        insertEnters2(db, "", "Операторы сравнения", "\n" +
                "int cat_age;\n" +
                "if(cat_age == 4) // нельзя if(cat_age) - нет сравнения\n" +
                "if(cat_age != 9) // нельзя if(!cat_age) - нет сравнения");
        insertEnters2(db, "", "Операторы сравнения", "Помните, что в Java значения true и false не являются числовыми значениями, как в C++, поэтому, чтобы сравнить значение с другим значением, необходимо явно использовать операторы сравнения.");


        insertEnters2(db, "", "Логические операторы", "Логические операторы");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "Логические операторы работают только с операндами типа boolean. Все логические операторы с двумя операндами объединяют два логических значения, образуя результирующее логическое значения. Не путайте с побитовыми логическими операторами.");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "Таблица логических операторов в Java");
        insertEnters2(db, "", "Логические операторы", "Оператор                  Описание\n" +
                "&                  Логическое AND (И)\n" +
                "&&                 Сокращённое AND\n" +
                "|                  Логическое OR (ИЛИ)\n" +
                "||                 Сокращённое OR\n" +
                "^                  Логическое XOR (исключающее OR (ИЛИ))\n" +
                "!                  Логическое унарное NOT (НЕ)\n" +
                "&=                 AND с присваиванием\n" +
                "|=                 OR с присваиванием\n" +
                "^=                 XOR с присваиванием\n" +
                "==                 Равно\n" +
                "!=                 Не равно\n" +
                "?:                 Тернарный (троичный) условный оператор");
        insertEnters2(db, "", "Логические операторы", "Логические операторы &, |, ^ действуют применительно к значениям типа boolean точно так же, как и по отношению к битам целочисленных значений. Логический оператор ! инвертирует (меняет на противоположный) булево состояние: !true == false и !false == true.");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "Таблица. Результаты выполнения логических операторов");
        insertEnters2(db, "", "Логические операторы", "A     B       A | B       A & B       A ^ B       !A\n" +
                "false      false       false        false         false      true\n" +
                "true       false       true         false         true        false\n" +
                "false      true        true         false         true         true\n" +
                "true       true        true         true         false        false");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "Сокращённые логические операторы");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "Кроме стандартных операторов AND (&) и OR (|) существуют сокращённые операторы && и ||.\n" +
                "\n" +
                "Если взглянуть на таблицу, то видно, что результат выполнения оператора OR равен true, когда значение операнда A равно true, независимо от значения операнда B. Аналогично, результат выполнения оператора AND равен false, когда значение операнда A равно false, независимо от значения операнда B. Получается, что нам не нужно вычислять значение второго операнда, если результат можно определить уже по первому операнду. Это становится удобным в тех случаях, когда значение правого операнда зависит от значения левого.\n" +
                "\n" +
                "Рассмотрим следующий пример. Допустим, мы ввели правило - кормить или не кормить кота в зависимости от числа пойманных мышек в неделю. Причём число мышек зависит от веса кота. Чем больше кот, тем больше он должен поймать мышей.");
        insertEnters2(db, "", "Логические операторы", "\n" +
                "int mouse; // число мышек\n" +
                "int weight; // вес кота в граммах\n" +
                "mouse = 5;\n" +
                "weight = 4500;\n" +
                "\n" +
                "if (mouse != 0 & weight / mouse < 1000) {\n" +
                "\tmInfoTextView.setText(\"Можно кормить кота\");\n" +
                "}");
        insertEnters2(db, "", "Логические операторы", "Если запустить программу, то пример будет работать без проблем - пять мышей в неделю вполне достаточно, чтобы побаловать кота вкусным завтраком. Если он поймает четырёх мышей, то начнутся проблемы с питанием кота, но не с программой - она будет работать, просто не будет выводить сообщение о разрешении покормить дармоеда.\n" +
                "\n" +
                "Теперь возьмём крайний случай. Кот обленился и не поймал ни одной мышки. Значение переменной mouse будет равно 0, а в выражении есть оператор деления. А делить на 0 нельзя и наша программа закроется с ошибкой. Казалось бы, мы предусмотрели вариант с 0, но Java вычисляет оба выражения mouse != 0 и weight / mouse < 1000, несмотря на то, что уже в первом выражении возвращается false.\n" +
                "\n" +
                "Перепишем условие следующим образом (добавим всего лишь один символ):");
        insertEnters2(db, "", "Логические операторы", "\n" +
                "if (mouse != 0 && weight / mouse < 1000) {\n" +
                "\tmInfoTextView.setText(\"Можно кормить кота\");\n" +
                "}");
        insertEnters2(db, "", "Логические операторы", "Теперь программа работает без краха. Как только Java увидела, что первое выражение возвращает false, то второе выражение с делением просто игнорируется.\n" +
                "\n" +
                "Сокращённые варианты операторов AND и OR принято использовать в тех ситуациях, когда требуются операторы булевой логики, а их односимвольные родственники используются для побитовых операций.");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "Тернарный оператор");
        insertEnters2(db, "", "Логические операторы", "");
        insertEnters2(db, "", "Логические операторы", "В языке Java есть также специальный тернарный условный оператор, которым можно заменить определённые типы операторов if-then-else - это оператор ?:\n" +
                "\n" +
                "Тернарный оператор использует три операнда. Выражение записывается в следующей форме:\n" +
                "\n");
        insertEnters2(db, "", "Логические операторы", "логическоеУсловие ? выражение1 : выражение2");
        insertEnters2(db, "", "Логические операторы", "Если логическоеУсловие равно true, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же логическоеУсловие равно false, то вычисляется выражение2, и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.\n" +
                "\n" +
                "Рассмотрим пример, в котором переменной absval присваивается абсолютное значение переменной val.");
        insertEnters2(db, "", "Логические операторы", "int absval, val;\n" +
                "val = 5;\n" +
                "absval = val < 0 ? -val : val;\n" +
                "\n" +
                "// выводим число\n" +
                "mInfoTextView.setText(\"\" + absval);\n" +
                "\n" +
                "val = -5;\n" +
                "absval = val < 0 ? -val : val;\n" +
                "\n" +
                "mInfoTextView.setText(\"\" + absval);\n");
        insertEnters2(db, "", "Логические операторы", "Переменной absval будет присвоено значение переменной val, если значение больше или равно нулю (вторая часть выражения). Если значение переменной val отрицательное, то переменной absval присваивается значение переменной, взятое со знаком минус, в результате минус на минус даст плюс, то есть положительно значение. Перепишем код с использованием if-else:");
        insertEnters2(db, "", "Логические операторы", "if(val < 0) absval = -val;\n" +
                "else absval = val;");


        insertEnters2(db, "","Оператор if","Условный оператор if часто применяется программистами и имеется во всех языках программирования. Оператор if позволяет вашей программе в зависимости от условий выполнить оператор или группу операторов, основываясь на значении булевой переменной или выражения. Оператор if является основным оператором выбора в Java и позволяет выборочно изменять ход выполнения программы - и это одно из основных отличий между программированием и простым вычислением.\n" +
                "\n" +
                "Оператор if начинается с ключевого слова if. Ключевое слово if должно сопровождаться булевым выражением, заключённым в скобки. Самая простая форма выглядит так:\n"
        +"\n"
             +"if (условие) оператор;  // если условие истинно, то выполняется оператор\n"+
                "\n"+
                "Здесь условие - это булево выражение, имеющее значение true или false. Если условие истинно, то оператор или группа операторов выполняется, если ложно, то оператор не выполняется. Очень часто булево выражение в операторе if содержит какое-нибудь сравнение, но можно использовать булеву переменную или константу\n"
                    +"\n"+
                        "// Если кот голоден\n" +
                        "if (isHungry)\n"+
                "\n"+
                "Оператор if продолжается заключенным в фигурные скобки фрагментом, который называют блоком операторов. Если используется только один оператор, то фигурные скобки можно опустить. Но практика показывает, что лучше их всегда использовать, особенно в сложных проектах, когда постоянно приходится что-то переделывать.\n" +
                        "\n" +
                        "Напишем следующий пример:\n"
                +"\n"
                +"if (2 * 2 == 5)\n" +
                        "{\n" +
                        "    mResultEditText.setText(\"Дважды два равно пяти!);\n" +
                        "}\n"
                +"Как вы думаете, что появится на экране? Правильно, ничего, так как оператор не будет выполняться, потому что условие 2 * 2 == 5 является ложным.\n" +
                        "\n" +
                        "Обратите внимание, что оператор равенства состоит из двух символов знака равно. Об этом часто забывают начинающие программисты.\n" +
                        "\n" +
                        "Вот список операторов, которые можно использовать в условных выражениях (не ставьте пробел между двумя символами и соблюдайте их очерёдность):\n"
                +"Оператор\tОписание\n" +
                        "<\tМеньше чем\n" +
                        "<=\tМеньше или равно\n" +
                        ">\tБольше чем\n" +
                        ">=\tБольше или равно\n" +
                        "==\tРавно\n" +
                        "!=\tНе равно"+
                "Результат сравнения удобно использовать для изменения логики программы. Например, если кот голоден, то накормить его. Или если число нечётное, то сделать его чётным.\n"+
                "\n" +
                        "if(number % 2 != 0)\n" +
                        "    ++number;\n"+
                "Существует расширенный вариант оператора if с использованием ключевого слова else:\n"+
                "if (условие) оператор;  // если условие истинно, то выполняется первый оператор\n" +
                        "else оператор;          // если условие ложно, то выполняется оператор после else\n"+
                "В этом случае при выполнении условия оператора if инициируется только один оператор, если условие не выполняется, то также инициируется только один оператор, который относится к else. Также можно использовать блоки операторов, тогда синтаксис будет выглядеть так:\n"+
                "if (условие)\n" +
                        "{\n" +
                        "    оператор1;\n" +
                        "    оператор2;\n" +
                        "}\n" +
                        "else\n" +
                        "{\n" +
                        "    оператор1;\n" +
                        "    оператор2;\n" +
                        "}\n"+
                "Обе части оператора if и else не могут выполняться одновременно. А условное выражение, управляющее оператором if должно возвращать булево значение.\n" +
                        "\n" +
                        "Возьмём пример из жизни. Выйдем на Манежную площадь, где собрались люди, поддерживающие Путина. У митингующих можно встретить плакат:\n"+
                "Попробуем перевести его на язык Java:\n"+
                "\n" +
                        "String who = mResultEditText.getText().toString();\n" +
                        "\n" +
                        "if (!who.equals(\"Putin\"))\n" +
                        "\twho = \"Cat\";\n" +
                        "else\n" +
                        "\twho = \"Putin\";\n" +
                        "mResultEditText.setText(who);\n"+
                "Запустите программу и пробуйте завести любые фамилии политиков, а затем щелкайте на кнопке. Вы увидите, что при вводе любой фамилии кроме Putin, президентом будет кот.\n" +
                        "\n"+
                "Вложенные операторы if\n" +
                        "Вложенный оператор if используется для дальнейшей проверки данных после того, как условие предыдущего оператора if принимает значение true. Иными словами, вложенный оператор применяется в тех случаях, когда для выполнения действия требуется соблюдение сразу нескольких условий, которые не могут быть указаны в одном условном выражении. Необходимо помнить, что во вложенных операторах if-else вторая часть else всегда относится к ближайшему оператору if, за условным выражением которого следует оператор ; или блок операторов. Вот небольшой пример:\n"+
                            "if(i == 10)\n" +
                                    "{\n" +
                                    "    if(j < 20) a = b;\n" +
                                    "    if(k > 100) c = d;\n" +
                                    "    else a = c;  // else относится к if(k > 100)\n" +
                                    "}\n" +
                                    "else a = d; // else относится к if(i == 10)\n"+
                                    "Цепочка операторов if-else-if\n" +
                                    "Часто используется цепочка операторов if-else-if - конструкция, состоящая из вложенных операторов if:\n"+
                                    "if (condition)\n" +
                                    "    statement;\n" +
                                    "else if (condition)\n" +
                                    "    statement;\n" +
                                    "else if (condition)\n" +
                                    "    statement;\n" +
                                    ".\n" +
                                    ".\n" +
                                    ".\n" +
                                    "else\n" +
                                    "    statement;\n"+
                                    "Условные выражения оцениваются сверху вниз. Как только найдено условие, принимающее значение true, выполняется ассоциированный с этим условием оператор, а остальная часть цепочки пропускается. Если ни одно из условий не принимает значение true, то выполняется последний оператор else, который можно рассматривать как оператор по умолчанию. Если же последний оператор else отсутствует, а все условные выражения принимают значение false, то программа не выполняет никаких действий.\n" +
                                    "\n" +
                                    "Напишем пример, вычисляющий время года, когда коты поют свои мартовские песни.\n"+
                                    "int month = 3; // март\n" +
                                    "String season; // время года\n" +
                                    "\n" +
                                    "if(month == 1 || month == 2 || month == 12)\n" +
                                    "    season = \"Зимушка-зима\";\n" +
                                    "else if (month == 3 || month == 4 || month == 5)\n" +
                                    "    season = \"Весна\";\n" +
                                    "else if (month == 6 || month == 7 || month == 8)\n" +
                                    "    season = \"Лето\";\n" +
                                    "else if (month == 9 || month == 10 || month == 11)\t\n" +
                                    "    season = \"Осень\";\n" +
                                    "else\n" +
                                    "    season = \"Вы с какой планеты?\";\n" +
                                    "\t\n" +
                                    "mInfoTextView.setText(\"Мартовские песни коты поют, когда на дворе \" + season);\n"+
                                    "Порядок условий имеет значение: если мы расположим условия if и else if в неправильном порядке, то может случится, что ни одна из ветвей else if не выполнится никогда.\n" +
                                    "\n" +
                                    "Ещё про котов (котов не бывает много). В зависимости от имени кота получаем его описание.\n"+
                                    "String catName = \"Рыжик\";\n" +
                                    "if (catName == \"Пушок\"){\n" +
                                    "    System.out.println(\"Ваш котёнок пушистенький\");\n" +
                                    "}\n" +
                                    "else if (catName == \"Рыжик\"){\n" +
                                    "    System.out.println(\"Ваш котёнок рыженький\");\n" +
                                    "}\n" +
                                    "else {\n" +
                                    "    System.out.println(\"Ваш котёнок ни пушистенький и ни рыженький\");\n" +
                                    "}\n"+
                                    "Гулять так гулять. Усложняем условия.\n"+
                                    "String[] cats = {\"Пушок\", \"Рыжик\", \"Лохматик\", \"Чудик\"};\n" +
                                    "Random random = new Random();\n" +
                                    "String catName = cats[random.nextInt(4)];\n" +
                                    "if (catName.equals(\"Пушок\")) {\n" +
                                    "    System.out.println(\"Ваш котёнок пушистенький\");\n" +
                                    "} else if (catName.equals(\"Рыжик\")) {\n" +
                                    "    System.out.println(\"Ваш котёнок рыженький\");\n" +
                                    "} else if (catName.equals(\"Лохматик\")) {\n" +
                                    "    System.out.println(\"Ваш котёнок лохматенький\");\n" +
                                    "} else if (catName.equals(\"Чудик\")) {\n" +
                                    "    System.out.println(\"Ваш котёнок чудной\");\n" +
                                    "} else {\n" +
                                    "    System.out.println(\"Ваш котёнок ни пушистенький и ни рыженький и не лохматый и ни чудной\");\n" +
                                    "}\n"+
                                    "Тернарный оператор\n" +
                                    "Продвинутые программисты часто используют тернарный оператор ? : вместо if-else. Тернарный оператор использует три операнда и записывается в форме:\n" +
                                    "\n"+
                                    "логическое_условие ? выражение1 : выражение2\n"+
                                    "Знак вопроса является переходом к блокам. Как видим, после вопросительного знака идут два блока. Если в условии получаем True, то используем первый блок. Если в условии у нас получается False, то используем второй блок.\n" +
                                    "\n" +
                                    "Например, нужно вычислить, какое из двух чисел больше и занести результат в третью переменную:\n"+
                                    "\n" +
                                    "int largerNum;  \n" +
                                    "int lowNum = 9;  \n" +
                                    "int highNum = 27; \n" +
                                    "\n" +
                                    "if(lowNum < highNum)  // если первое число меньше второго\n" +
                                    "{  \n" +
                                    "    largerNum = highNum;\n" +
                                    "} else {  // иначе\n" +
                                    "    largerNum = lowNum;  \n" +
                                    "} \n"+
                                    "\n"+
                                    "При тернарном варианте код будет следующим:\n" +
                                    "\n"+
                                    "int lowNum = 9;  \n" +
                                    "int highNum = 27;  \n" +
                                    "int largerNum = lowNum < highNum ? highNum : lowNum;\n"+
                                    "Сравниваем два заданных числа. Так как 9 меньше 27, то берём выражение из первого блока, т.е. highNum.\n" +
                                    "\n" +
                                    "Нельзя сказать, что такой код слишком читаем, поэтому можно не использовать в своей практике.");

//        insertEnters2(db, "NISSA", "MONO-GREEN","");
    insertEnters2(db, "FOOD","MONO-GREEN","");
//
//
//
//
//
//        insertEnters2(db, "LIFE", "MONO-WHITE","");
//
//
//
//
//
//        insertEnters2(db, "WEENIE","MONO-WHITE","");
//
//
//
//


        Log.i("MyLog", "After insert2");



    }

    @Override
    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

    }
}
