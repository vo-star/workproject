package com.example.mtg_deck;

import android.content.ContentValues;
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;
import android.widget.Toast;

public class DeckDatabaseHelper extends SQLiteOpenHelper {

    private static final String DB_NAME = "deck"; // the name of our database
    private static final int DB_VERSION = 2; // the version of the database

    DeckDatabaseHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }
    private static void insertEnters1(SQLiteDatabase db, String color){
        ContentValues colorsEnters = new ContentValues();
        colorsEnters.put("COLOR", color);
        db.insert("COLORS", null, colorsEnters);
    }
    private static void insertEnters2(SQLiteDatabase db, String type, String color, String com) {
        ContentValues blueEnters = new ContentValues();
        blueEnters.put("TYPE", type);
        blueEnters.put("COLOR", color);
        blueEnters.put("COM", com);
        db.insert("DECK_COLORS", null, blueEnters);
    }
    private static void insertEnters3(SQLiteDatabase db,String color,  String type, String card, int resursID, int sign) {
        ContentValues cardEnters = new ContentValues();

        cardEnters.put("COLOR", color);
        cardEnters.put("TYPE", type);
        cardEnters.put("CARD", card);
        cardEnters.put("RESURSID", resursID);
        cardEnters.put("SIGN", sign);

        db.insert("CARDS", null, cardEnters);
    }

    @Override
    public void onCreate(SQLiteDatabase db){
        db.execSQL("CREATE TABLE COLORS (_id INTEGER PRIMARY KEY AUTOINCREMENT, COLOR TEXT); " );
        Log.i("MyLog", "After create table1");
        //added headers
        insertEnters1(db, "Типы");
        insertEnters1(db, "Побитовые операторы");
        insertEnters1(db, "Операторы сравнения");
       insertEnters1(db, "Логические операторы");
//        insertEnters1(db, "Литералы");
//        insertEnters1(db, "Оператор if");
//        insertEnters1(db, "Оператор switch");
//        insertEnters1(db, "Цикл while");
//        insertEnters1(db, "Цикл do-while");
//        insertEnters1(db, "Цикл for");
//        insertEnters1(db, "Операторы перехода break, continue, return");
//        insertEnters1(db, "Классы и объекты");
//        insertEnters1(db, "Класс Object");
//        insertEnters1(db, "Методы");
//        insertEnters1(db, "Видимость. Спецификаторы доступа");
//        insertEnters1(db, "Ключевое слово static");
//        insertEnters1(db, "Вложенные и внутренние классы");
//        insertEnters1(db, "Конструктор");
//        insertEnters1(db, "Шаблон Builder");
//        insertEnters1(db, "Шаблон Singleton");
//        insertEnters1(db, "Наследование");
//        insertEnters1(db, "Абстрактные классы и методы");
//        insertEnters1(db, "Пакеты");
//        insertEnters1(db, "Интерфейсы");
//        insertEnters1(db, "Слушатели");
//        insertEnters1(db, "Исключения");
//        insertEnters1(db, "Потоки. Класс Thread и интерфейс Runnable");
//        insertEnters1(db, "Перечисления enum");
//        insertEnters1(db, "Обобщения (Generic)");
//        insertEnters1(db, "Рекурсия");
//        insertEnters1(db, "Класс String");
//        insertEnters1(db, "Класс Scanner");
//        insertEnters1(db, "Класс Math");
//        insertEnters1(db, "Классы Date, Calendar, DateFormat");
//        insertEnters1(db, "Класс Currency");
//        insertEnters1(db, "Locale");
//        insertEnters1(db, "Массивы");
//        insertEnters1(db, "Stack");
//        insertEnters1(db, "Коллекции");
//        insertEnters1(db, " ArrayList");
//        insertEnters1(db, " LinkedList");
//        insertEnters1(db, "Множества: Set, HashSet, LinkedHashSet, TreeSet");
//        insertEnters1(db, "Map (Отображение)");
//        insertEnters1(db, "HashMap");
//        insertEnters1(db, " LinkedHashMap");
//        insertEnters1(db, "  ArrayMap и SparseArray");
//        insertEnters1(db, "Интерфейс Comparable");
//        insertEnters1(db, "Интерфейс Comparator");
//        insertEnters1(db, "Система ввода/вывода");
//        insertEnters1(db, " Класс File");
//        insertEnters1(db, "  Класс InputStream");
//        insertEnters1(db, " Класс PrintStream");
//        insertEnters1(db, "Классы NIO");
//        insertEnters1(db, "Random");
//        insertEnters1(db, "Таймер - классы Timer и TimerTask");
//        insertEnters1(db, "Обработка событий");
//        insertEnters1(db, "Регулярные выражения");
        Log.i("MyLog", "After insert1");
        db.execSQL("CREATE TABLE DECK_COLORS (_id INTEGER PRIMARY KEY AUTOINCREMENT, TYPE TEXT, COLOR TEXT, COM TEXT); " );
        Log.i("MyLog", "After create table2");


        //added note

        insertEnters2(db, "", "Типы", "Примитивные типы Java не являются объектами. К ним относятся:");
        insertEnters2(db," ", "Типы"," boolean - булев тип, может иметь значения true или false");
        insertEnters2(db," ", "Типы","byte - 8-разрядное целое число");
        insertEnters2(db," ", "Типы"," short - 16-разрядное целое число");
        insertEnters2(db," ", "Типы"," int - 32-разрядное целое число");
        insertEnters2(db," ", "Типы"," long - 64-разрядное целое число");
        insertEnters2(db," ", "Типы"," char - 16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)");
        insertEnters2(db," ", "Типы","float - 32-разрядное число в формате IEEE 754 с плавающей точкой");
        insertEnters2(db," ", "Типы"," double - 64-разрядное число в формате IEEE 754 с плавающей точкой");
        insertEnters2(db," ", "Типы",   " Примитивный в данном случае не оскорбление, а просто даёт понять, что речь идёт о простом типе, который не умеет прыгать, спать или мяукать. Да что он вообще умеет? Ой, всё."
                +       " Java определяет четыре целочисленных типа: byte, short, int, long. Они могут быть положительными и отрицательными (Java не поддерживает только положительные значения без знака, как некоторые языки программирования)."
                +      " Тип byte "
                +" Наименьший по размеру целочисленный тип - byte. Это 8-битовый тип с диапазоном допустимых значений от -128 до 127. Переменные типа byte часто используются при работе с потоком данных из сети или файла, а также при работе с необработанными двоичными данными или в массивах для экономии памяти. "

                +       " Объявить переменную типа byte можно следующим образом: ");

        insertEnters2(db," ", "Типы","");
        insertEnters2(db," ", "Типы"," byte c, a, t; // объявили сразу три переменные ");
        insertEnters2(db," ", "Типы"," ");
        insertEnters2(db," ", "Типы",    " В арифметических выражениях с переменными типа byte вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Смотри пример с short." +
                              " Строку с числом перевести в данный тип можно через метод parseByte(String): " +
                        "\n" +
                        " byte x = Byte.parseByte('100'); " +
                "\n"+
                         "Класс Byte является оболочкой для данного типа. Без необходимости не используйте в Android класс Byte. " +
                " Слово «байт» (byte) возникло в компании IBM примерно в 1956 году. Оно произошло от слова bite («кусок»), но его было решено писать через букву y, чтобы не путать со словом «bit» («бит»). В течение некоторого времени слово «байт» обозначало просто число битов в конкретном потоке данных. Однако в середине 1960-х, в связи с разработкой семейства компьютеров System/360 в компании IBM, это слово стало обозначать группу из восьми бит." +
                " Любопытно, что bite имеет также значение 'укус' (сущ.) или 'укусить' (глагол). Таким образом это наш родной 'Кусь!'\");"
        +  " В арифметических выражениях с переменными типа byte вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Смотри пример с short."
                + " Строку с числом перевести в данный тип можно через метод parseByte(String): "
                + " byte x = Byte.parseByte('100'); "
                + " Класс Byte является оболочкой для данного типа. Без необходимости не используйте в Android класс Byte. "
                + " Слово «байт» (byte) возникло в компании IBM примерно в 1956 году. Оно произошло от слова bite («кусок»), но его было решено писать через букву y, чтобы не путать со словом «bit» («бит»). В течение некоторого времени слово «байт» обозначало просто число битов в конкретном потоке данных. Однако в середине 1960-х, в связи с разработкой семейства компьютеров System/360 в компании IBM, это слово стало обозначать группу из восьми бит. "
                + " Любопытно, что bite имеет также значение 'укус' (сущ.) или 'укусить' (глагол). Таким образом это наш родной 'Кусь!'");





        insertEnters2(db, "", "Побитовые операторы","Существует несколько побитовых операторов, применимых к целочисленными типам long, int, short, char, byte.");
        insertEnters2(db, "", "Побитовые операторы", "~\tПобитовый унарный оператор NOT");
        insertEnters2(db, "", "Побитовые операторы","&\tПобитовый AND");
        insertEnters2(db, "", "Побитовые операторы","&=\tПобитовый AND с присваиванием");
        insertEnters2(db, "", "Побитовые операторы","|\tПобитовый OR");
        insertEnters2(db, "", "Побитовые операторы","|=\tПобитовый OR с присваиванием");
        insertEnters2(db, "", "Побитовые операторы","^\tПобитовый исключающее OR");
        insertEnters2(db, "", "Побитовые операторы","^=\tПобитовый исключающее OR с присваиванием");
        insertEnters2(db, "", "Побитовые операторы",">>\tСдвиг вправо");
        insertEnters2(db, "", "Побитовые операторы",">>=\tСдвиг вправо с присваиванием");
        insertEnters2(db, "", "Побитовые операторы",">>>\tСдвиг вправо с заполнением нулями");
        insertEnters2(db, "", "Побитовые операторы","<<\tСдвиг влево");
        insertEnters2(db, "", "Побитовые операторы","<<=\tСдвиг влево с присваиванием");
        insertEnters2(db, "", "Побитовые операторы",">>>=\tСдвиг вправо с заполнением нулями с присваиванием");
        insertEnters2(db, "", "Побитовые операторы","Все целочисленные типы представляются двоичными числами различной длины. Например, значение типа byte, равное 42, в двоичном представлении имеет вид 00101010, в котором каждая позиция представляет степень числа два."
        +"\n"
        +"\nВсе целочисленные типа, за исключением char - типы со знаком, т.е. могут быть положительными или отрицательными. В Java применяется двоичное дополнение, при котором отрицательные числа представляются в результате инвертирования всех битов значения (изменения 1 на 0 и наоборот) и последующего добавления 1 к результату. Например, -42 представляется в результате инвертирования всех битов в двоичном представлении числа 42, что даёт значение 11010101, и добавления 1, что приводит к значению 110110110, или -42. Чтобы декодировать отрицательное число, необходимо вначале инвертировать все биты, а затем добавить 1 к результату. Например, инвертирование значения -42, или 11010110, приводит к значению 00101001, или 41, после добавления 1 к которому мы получим 42."
        +"\n"
        +"\nДвоичное дополнение используется в большинстве компьютерных языков. Опустим теорию, нужно только помнить, что старший бит определяет знак целого числа.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовые логические операторы");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовые логические операторы - это &, |, ^, ~. Побитовые операторы применяются к каждому отдельному биту каждого операнда.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Результаты выполнения побитовых логических операторов");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","A      B       A|B     A&B     A^B     ~A"
                                                                        +"\n"
        +                                                           " 0       0         0       0         0            1"
                +"\n"
        +                                                           " 1       0         1       0         1            0"
                +"\n"
        +                                                           " 0       1         1       0         1            1"
                +"\n"
        +                                                           " 1       1         1       1         0            0"

                                                            );
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовое OR (|)");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Результирующий бит, полученный в результате выполнения оператора OR, |, равен 1, если соответствующий бит в любом из операндов равен 1.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы"," 00101010  42\n" +
                "| 00001111  15\n" +
                "  --------------\n" +
                "  00101111  47 ");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовое AND (&)");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Значение бита, полученное в результате выполнения побитового оператора AND, &, равно 1, если соответствующие биты в операндах также равны 1. Во всех остальных случаях значение результирующего бита равно 0.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","  00101010  42\n" +
                "& 00001111  15\n" +
                "--------------\n" +
                "  00001010  10");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовое XOR (^)");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Результирующий бит, полученный в результате выполнения оператора XOR, ^, равен 1, если соответствующий бит только в одном из операндов равен 1. Во всех других случаях результирующий бит равен 0.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы"," 00101010  42\n" +
                "^ 00001111  15\n" +
                "--------------\n" +
                "  00100101  37  ");
        insertEnters2(db, "", "Побитовые операторы","Данный оператор обладает полезной особенностью, часто используемый в программировании. Например, можно обменять значения переменных без использования дополнительной переменной");
        insertEnters2(db, "", "Побитовые операторы","\n" +
                "int x = 5, y = 7;\n" +
                "\n" +
                "x = x ^ y; // стало 2\n" +
                "System.out.println(x);\n" +
                "y = x ^ y; // стало 5\n" +
                "System.out.println(y);\n" +
                "x = x ^ y; //стало 7\n" +
                "System.out.println(x);");
        insertEnters2(db, "", "Побитовые операторы","Но увлекаться такой записью не стоит, это работает медленнее и код менее читаем.\n" +
                "\n" +
                "Гораздо шире используется XOR для шифрования. В простейшем виде это выглядит так. Есть текст, к которому применяется ключ с оператором XOR. Зашифрованное сообщение передаётся человеку, который знает ключ. Всё, что ему нужно сделать - это применить к зашифрованному тексту тот же ключ, используемый для шифровки и текст снова станет читаемым.\n" +
                "\n" +
                "Ниже приводится приблизительный пример работы шифровки/дешифровки текста. С русским текстом пример не будет работать, так как используются разные кодировки и требуется писать дополнительный код. Итак, у нас есть некий текст, который мы зашифровали с помощью ключа (meow) и передали полученный набор байтов другому человеку. Если кто-то перехватит ваше сообщение, то увидит просто набор символов. А ваш сообщник сможет прочитать сообщение, так как вы заранее условились, каким будем ключ для расшифровки.");
        insertEnters2(db, "", "Побитовые операторы","public void onClick(View view) {\n" +
                "\n" +
                "\tString message = \"OK, i love you\"; // секретное сообщение\n" +
                "\tString catkey = \"meow\"; // ключ\n" +
                "\n" +
                "\t// зашифруем послание\n" +
                "\tbyte[] important = encode(message, catkey);\n" +
                "\t// посмотрим на результат\n" +
                "\tmInfoTextView.setText(new String(important));\n" +
                "\n" +
                "\t// теперь расшифруем текст\n" +
                "\tmResultEditText.setText(decode(mInfoTextView.getText().toString().getBytes(),\n" +
                "\t\t\tcatkey));\n" +
                "\t\n" +
                "}\n" +
                "\n" +
                "// метод для шифровки текста с помощью XOR\n" +
                "public static byte[] encode(String secret, String key) {\n" +
                "\tbyte[] btxt = null;\n" +
                "\tbyte[] bkey = null;\n" +
                "\n" +
                "\tbtxt = secret.getBytes();\n" +
                "\tbkey = key.getBytes();\n" +
                "\n" +
                "\tbyte[] result = new byte[secret.length()];\n" +
                "\n" +
                "\tfor (int i = 0; i < btxt.length; i++) {\n" +
                "\t\tresult[i] = (byte) (btxt[i] ^ bkey[i % bkey.length]);\n" +
                "\t}\n" +
                "\treturn result;\n" +
                "}\n" +
                "\n" +
                "// метод для расшифровки текста\n" +
                "public static String decode(byte[] secret, String key) {\n" +
                "\tbyte[] result = new byte[secret.length];\n" +
                "\tbyte[] bkey = key.getBytes();\n" +
                "\n" +
                "\tfor (int i = 0; i < secret.length; i++) {\n" +
                "\t\tresult[i] = (byte) (secret[i] ^ bkey[i % bkey.length]);\n" +
                "\t}\n" +
                "\treturn new String(result);\n" +
                "}");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовое NOT (~)");
        insertEnters2(db, "", "Побитовые операторы","Унарный оператор NOT (Не), ~, называемый также побитовым дополнением, инвертирует все биты операнда. Например, число 42 в битовом представлении имеет вид:");
        insertEnters2(db, "", "Побитовые операторы","00101010");
        insertEnters2(db, "", "Побитовые операторы","В результате применения оператора NOT преобразуется в значение:");
        insertEnters2(db, "", "Побитовые операторы","11010101");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Сдвиг влево");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Оператор сдвига влево, <<, смещает все биты влево на указанное количество позиций:");
        insertEnters2(db, "", "Побитовые операторы","значение << количество");
        insertEnters2(db, "", "Побитовые операторы","Параметр количество указывает, на сколько нужно сдвинуть влево биты в параметре значение. При каждом сдвиге влево самый старший бит смещается за пределы допустимого значения и теряется, а справа дописывается нуль. Это означает, что при применении оператора сдвига влево к операнду типа int биты теряются, как только они сдвигаются за пределы 31 позиции. Если операнд имеет тип long, биты теряются после сдвига за пределы 63 позиции.\n" +
                "\n" +
                "Автоматическое повышение типа, используемое в Java, может привести к странным результатам при выполнении сдвига в значениях типа byte, short. При вычислении выражений тип значений byte и short повышается до типа int. Это означает, что результатом выполнения сдвига влево значения типа byte или short будет значение int, и сдвинутые влево позиции не будут отброшены до тех пор, пока они не будут сдвинуты за пределы 31 позиции. Более того, при повышении до типа int отрицательное значение типа byte или short получит дополнительный знаковый разряд. Следовательно, старшие биты будут заполнены единицами. Поэтому выполнение оператора сдвига влево предполагает необходимость отбрасывания старших байтов результата типа int. Иными словами, при выполнении сдвига влево в значении типа byte сначала будет повышение до типа int и лишь затем сдвиг. Это означает, что для получения требуемого сдвинутого значения типа byte необходимо отбросить три старших байта результата. Простейший способ достижения этого - обратное приведение результата к типу byte.");
        insertEnters2(db, "", "Побитовые операторы","\n" +
                "byte x = 64;\n" +
                "byte y;\n" +
                "int i;\n" +
                "\n" +
                "i = x << 2; // сдвиг влево\n" +
                "y = (byte) (x << 2); // сдвиг влево с приведением\n" +
                "\n" +
                "\n" +
                "mInfoTextView.append(\"i равно: \" + i + \"\\n\");\n" +
                "mInfoTextView.append(\"y равно: \" + y);");
        insertEnters2(db, "", "Побитовые операторы","Результат будет следующим:");
        insertEnters2(db, "", "Побитовые операторы","i равно: 256\n" +
                "y равно: 0");
        insertEnters2(db, "", "Побитовые операторы","Поскольку для выполнения вычислений тип переменной повышается до int, сдвиг влево на две позиции значение 64 (0100 0000) приводит к значению 256 (1 0000 0000). Однако, переменная y содержит значение не 256, а 0, поскольку после сдвига крайний единичный бит оказывается сдвинутым за пределы допустимого диапазона.\n" +
                "\n" +
                "Приёмом сдвига влево часто пользуются в программах, где происходит много сложных вычислений. По сути, это замена операции умножения на 2, которая в силу особенностей процессора гораздо эффективнее. При этом следует соблюдать осторожность, так как при сдвиге единичного бита в старшую позицию (бит 31 или 63) значение становится отрицательным.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Сдвиг вправо");
        insertEnters2(db, "", "Побитовые операторы","Оператор сдвига вправо, >>, смещает все биты значения вправо на указанное количество позиций:");
        insertEnters2(db, "", "Побитовые операторы","значение >> количество");
        insertEnters2(db, "", "Побитовые операторы","Вы указываете количество позиций, на которое нужно сдвинуть вправо биты в значении. Следующий код выполняет сдвиг право на две позиции в значении 32, в результате чего значение переменной станет равным 8.");
        insertEnters2(db, "", "Побитовые операторы","int a = 32;\n" +
                "a = a >> 2 // стало равным 8");
        insertEnters2(db, "", "Побитовые операторы","Крайние биты при сдвиге просто теряются. Например, значение 35 при сдвиге вправо на две позиции также приводит к значению 8, так как теряются два младщих бита.");
        insertEnters2(db, "", "Побитовые операторы","  00100011  35\n" +
                ">>2\n" +
                "----------\n" +
                "  00001000  8");
        insertEnters2(db, "", "Побитовые операторы","При каждом сдвиге вправо выполняется деление на два с отбрасыванием любого остатка. Данная операция намного эффективнее, чем обычное деление на два, поэтому часто используется в сложных вычислениях. При этом нужно быть уверенным, что никакие биты не будут сдвинуты за пределы правой границы.\n" +
                "\n" +
                "При выполнении сдвига вправо старшие (расположенные в крайних левых позициях) биты, освобожденные в результате сдвига, заполняются предыдущим содержимым старшего бита. Этот эффект называется дополнительных знаковым разрядом и служит для сохранения знака отрицательных чисел при их сдвиге.\n" +
                "\n" +
                "Обратите внимание, что результат сдвига вправо значения -1 всегда равен -1, поскольку дополнительные знаковые разряды добавляют новые единицы к старшим битам.\n" +
                "\n" +
                "Иногда при выполнении сдвига вправо появление дополнительных знаковых разрядов нежелательно. В этом случае используется маскировка за счёт объединения значения со значением 0x0f оператором AND, что приводит к отбрасыванию любых битов дополнительных знаковых разрядов.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Сдвиг вправо без учёта знака");
        insertEnters2(db, "", "Побитовые операторы","Как было показано выше, при каждом выполнении оператор >> автоматически заполняет старший бит его предыдущим содержимым. В результате знак значения сохраняется. Однако иногда это нежелательно. Например, при работе со значениями пикселей и графическими изображениями. Как правило, в этих случаях требуется сдвиг нуля в позицию старшего бита независимо от его первоначального значения. Такое действие называют сдвигом вправо без учета знака, когда всегда вставляется нуль в позицию старшего бита.\n" +
                "\n" +
                "Допустим, мы хотим сдвинуть вправо на 24 бит значение -1 (в двоичном представлении 11111111 11111111 11111111 11111111):");
        insertEnters2(db, "", "Побитовые операторы","    11111111 11111111 11111111 11111111\n" +
                ">>> 24\n" +
                "---------------------------------------\n" +
                "    00000000 00000000 00000000 11111111 255 в двоичном виде типа int");
        insertEnters2(db, "", "Побитовые операторы","Оператор >>> не столь полезен, поскольку имеет смысл только для 32- и 64-разрядных значений.");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Побитовые составные операторы с присваиванием");
        insertEnters2(db, "", "Побитовые операторы","");
        insertEnters2(db, "", "Побитовые операторы","Двоичные побитовые операторы имеют составную форму, которая объединяет побитовый оператор с оператором присваивания.");
        insertEnters2(db, "", "Побитовые операторы","\n" +
                "a = a >> 4;\n" +
                "a >>= 4;\n" +
                "\n" +
                "a = a | b;\n" +
                "a |= b;");







        insertEnters2(db, "","Операторы сравнения","Операторы сравнения");
        insertEnters2(db, "","Операторы сравнения","");
        insertEnters2(db, "","Операторы сравнения","Операторы сравнения выдают логический результат (boolean). Если условие проверки истинно, оператор выдает true, а если ложно - false. К операторам сравнения относятся < (меньше чем), > (больше чем), <= (меньше чем или равно), >= (больше чем или равно), == (равно), != (не равно). Операторы \"Равно\" и \"не равно\" можно использовать для всех примитивных типов данных, однако остальные сравнения нельзя использовать к типу boolean.");
        insertEnters2(db, "","Операторы сравнения","Оператор\tПример использования\tВозвращает значение \"истинно\", если...\n" +
                ">      a > b       а больше b\n" +
                ">=     a >= b      а больше или равно b\n" +
                "<      a < b       а меньше b\n" +
                "<=     a <= b      а меньше или равно b\n" +
                "==     a == b     а равно b\n" +
                "!=     a != b      а не равно b\n" +
                "&&     a && b     а и b истинны, b оценивается условно (если а ложно, b не вычисляется)\n" +
                "||     a || b      а или b истинно, b оценивается условно (если а истинно, b не вычисляется)\n" +
                "!      !a          а ложно\n" +
                "&      a & b       а и b истинны, b оценивается в любом случае\n" +
                "|      a | b       а или b истинно, b оценивается в любом случае\n" +
                "^      a ^ b       а и b различны");
        insertEnters2(db, "","Операторы сравнения","Наиболее часто операции сравнения используют в выражениях, которые управляют оператором if и операторами цикла.\n" +
                "\n" +
                "Обратите внимание, что равенство обозначается двумя знаками равно (==), одиночный знак равно (=) - это оператор присваивания. Типичная ошибка начинающих программистов.\n" +
                "\n" +
                "Корректный вариант примера:");
        insertEnters2(db, "","Операторы сравнения","\n" +
                "int x = 5;\n" +
                "int y = 7;\n" +
                "boolean z = a < b; // результат сохраняется в переменной типа boolean");
        insertEnters2(db, "","Операторы сравнения","Примеры для оператора if для Java (В C++ используется другой синтаксис!):");
        insertEnters2(db, "","Операторы сравнения","\n" +
                "int cat_age;\n" +
                "if(cat_age == 4) // нельзя if(cat_age) - нет сравнения\n" +
                "if(cat_age != 9) // нельзя if(!cat_age) - нет сравнения");
        insertEnters2(db, "","Операторы сравнения","Помните, что в Java значения true и false не являются числовыми значениями, как в C++, поэтому, чтобы сравнить значение с другим значением, необходимо явно использовать операторы сравнения.");





        insertEnters2(db, "", "Логические операторы","Логические операторы");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","Логические операторы работают только с операндами типа boolean. Все логические операторы с двумя операндами объединяют два логических значения, образуя результирующее логическое значения. Не путайте с побитовыми логическими операторами.");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","Таблица логических операторов в Java");
        insertEnters2(db, "", "Логические операторы","Оператор          Описание\n" +
                "&          Логическое AND (И)\n" +
                "&&         Сокращённое AND\n" +
                "|          Логическое OR (ИЛИ)\n" +
                "||         Сокращённое OR\n" +
                "^          Логическое XOR (исключающее OR (ИЛИ))\n" +
                "!          Логическое унарное NOT (НЕ)\n" +
                "&=         AND с присваиванием\n" +
                "|=         OR с присваиванием\n" +
                "^=         XOR с присваиванием\n" +
                "==         Равно\n" +
                "!=         Не равно\n" +
                "?:         Тернарный (троичный) условный оператор");
        insertEnters2(db, "", "Логические операторы","Логические операторы &, |, ^ действуют применительно к значениям типа boolean точно так же, как и по отношению к битам целочисленных значений. Логический оператор ! инвертирует (меняет на противоположный) булево состояние: !true == false и !false == true.");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","Таблица. Результаты выполнения логических операторов");
        insertEnters2(db, "", "Логические операторы","A     B       A | B       A & B       A ^ B       !A\n" +
                "false      false       false        false         false      true\n" +
                "true       false       true         false         true        false\n" +
                "false      true        true         false         true         true\n" +
                "true       true        true         true         false        false");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","Сокращённые логические операторы");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","Кроме стандартных операторов AND (&) и OR (|) существуют сокращённые операторы && и ||.\n" +
                "\n" +
                "Если взглянуть на таблицу, то видно, что результат выполнения оператора OR равен true, когда значение операнда A равно true, независимо от значения операнда B. Аналогично, результат выполнения оператора AND равен false, когда значение операнда A равно false, независимо от значения операнда B. Получается, что нам не нужно вычислять значение второго операнда, если результат можно определить уже по первому операнду. Это становится удобным в тех случаях, когда значение правого операнда зависит от значения левого.\n" +
                "\n" +
                "Рассмотрим следующий пример. Допустим, мы ввели правило - кормить или не кормить кота в зависимости от числа пойманных мышек в неделю. Причём число мышек зависит от веса кота. Чем больше кот, тем больше он должен поймать мышей.");
        insertEnters2(db, "", "Логические операторы","\n" +
                "int mouse; // число мышек\n" +
                "int weight; // вес кота в граммах\n" +
                "mouse = 5;\n" +
                "weight = 4500;\n" +
                "\n" +
                "if (mouse != 0 & weight / mouse < 1000) {\n" +
                "\tmInfoTextView.setText(\"Можно кормить кота\");\n" +
                "}");
        insertEnters2(db, "", "Логические операторы","Если запустить программу, то пример будет работать без проблем - пять мышей в неделю вполне достаточно, чтобы побаловать кота вкусным завтраком. Если он поймает четырёх мышей, то начнутся проблемы с питанием кота, но не с программой - она будет работать, просто не будет выводить сообщение о разрешении покормить дармоеда.\n" +
                "\n" +
                "Теперь возьмём крайний случай. Кот обленился и не поймал ни одной мышки. Значение переменной mouse будет равно 0, а в выражении есть оператор деления. А делить на 0 нельзя и наша программа закроется с ошибкой. Казалось бы, мы предусмотрели вариант с 0, но Java вычисляет оба выражения mouse != 0 и weight / mouse < 1000, несмотря на то, что уже в первом выражении возвращается false.\n" +
                "\n" +
                "Перепишем условие следующим образом (добавим всего лишь один символ):");
        insertEnters2(db, "", "Логические операторы","\n" +
                "if (mouse != 0 && weight / mouse < 1000) {\n" +
                "\tmInfoTextView.setText(\"Можно кормить кота\");\n" +
                "}");
        insertEnters2(db, "", "Логические операторы","Теперь программа работает без краха. Как только Java увидела, что первое выражение возвращает false, то второе выражение с делением просто игнорируется.\n" +
                "\n" +
                "Сокращённые варианты операторов AND и OR принято использовать в тех ситуациях, когда требуются операторы булевой логики, а их односимвольные родственники используются для побитовых операций.");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","Тернарный оператор");
        insertEnters2(db, "", "Логические операторы","");
        insertEnters2(db, "", "Логические операторы","В языке Java есть также специальный тернарный условный оператор, которым можно заменить определённые типы операторов if-then-else - это оператор ?:\n" +
                "\n" +
                "Тернарный оператор использует три операнда. Выражение записывается в следующей форме:\n" +
                "\n");
        insertEnters2(db, "", "Логические операторы","логическоеУсловие ? выражение1 : выражение2");
        insertEnters2(db, "", "Логические операторы","Если логическоеУсловие равно true, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же логическоеУсловие равно false, то вычисляется выражение2, и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.\n" +
                "\n" +
                "Рассмотрим пример, в котором переменной absval присваивается абсолютное значение переменной val.");
        insertEnters2(db, "", "Логические операторы","int absval, val;\n" +
                "val = 5;\n" +
                "absval = val < 0 ? -val : val;\n" +
                "\n" +
                "// выводим число\n" +
                "mInfoTextView.setText(\"\" + absval);\n" +
                "\n" +
                "val = -5;\n" +
                "absval = val < 0 ? -val : val;\n" +
                "\n" +
                "mInfoTextView.setText(\"\" + absval);");
        insertEnters2(db, "", "Логические операторы","Переменной absval будет присвоено значение переменной val, если значение больше или равно нулю (вторая часть выражения). Если значение переменной val отрицательное, то переменной absval присваивается значение переменной, взятое со знаком минус, в результате минус на минус даст плюс, то есть положительно значение. Перепишем код с использованием if-else:");
        insertEnters2(db, "", "Логические операторы","if(val < 0) absval = -val;\n" +
                "else absval = val;");






//        insertEnters2(db, "DISCARD","MONO-BLACK","");
//
//
//
//
//
//
//        insertEnters2(db, "NISSA", "MONO-GREEN","");
//
//
//
//
//
//        insertEnters2(db, "FOOD","MONO-GREEN","");
//
//
//
//
//
//        insertEnters2(db, "LIFE", "MONO-WHITE","");
//
//
//
//
//
//        insertEnters2(db, "WEENIE","MONO-WHITE","");
//
//
//
//



        Log.i("MyLog", "After insert2");
        db.execSQL("CREATE TABLE CARDS (_id INTEGER PRIMARY KEY AUTOINCREMENT,COLOR TEXT ,TYPE TEXT , CARD TEXT, RESURSID INTEGER, SIGN INTEGER); " );
        insertEnters3(db, "MONO-BLUE","MILS" , "4 Мерфолк, Хранительница Тайн", R.drawable.merfolk, 0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Ошеломленная Ученица", R.drawable.lener, 0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Горгулья Вантресса", R.drawable.gorg,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Стена Потерянных Мыслей", R.drawable.faol,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "3 Холодный Отказ", R.drawable.coald,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Скажи Волшебное Слово", R.drawable.woard,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Распад Мыслей", R.drawable.one,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "3 Попасть в Историю", R.drawable.two,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Ведьмин Колодец", R.drawable.three,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Затонувшие Тайны",  R.drawable.five,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "1 Замок Вантресс",  R.drawable.six,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "17 Остров",  R.drawable.seven,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "4 Мистическое Святилище",  R.drawable.thore,0);
        insertEnters3(db, "MONO-BLUE", "MILS", "",  0 ,1);
        insertEnters3(db, "MONO-BLUE", "MILS", "Доп. колода:",  0 ,1);
        insertEnters3(db, "MONO-BLUE", "MILS", "3 Такой Крохотный",  R.drawable.sid1 ,0);
    }

    @Override
    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {

    }

}
